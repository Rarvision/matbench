name: env-setup-and-docker-create

on:
  workflow_call:
    inputs:
      model:
        description: "The model name"
        required: true
        type: string
      python_version:
        description: "Python version to use"
        required: true
        type: string
      system_dependencies:
        description: "Additional system dependencies to install"
        required: false  
        type: string
        default: "git"
      conda_env_file:
        description: "Optional Conda environment YAML file for setup"
        required: false
        type: string
      pip_requirements_file:
        description: "Optional pip requirements.txt file for setup"
        required: false
        type: string
      custom_pip_lines:
        description: "Optional custom pip install lines; each commands should be separated by semicolon"
        required: false
        type: string
      dockerhub_repo:
        description: "Docker Hub repository, e.g. username/my-image"
        required: true
        type: string

jobs:
  setup:
    runs-on: ubuntu-latest

    steps:
      - name: Install system dependencies
        run: |
          if [ ! -z "${{ inputs.system_dependencies }}" ]; then
            echo "Installing additional dependencies: ${{ inputs.system_dependencies }}"
            sudo apt-get update
            sudo apt-get install -y ${{ inputs.system_dependencies }}
          fi

      - name: Checkout repository
        uses: actions/checkout@v4 

      - name: Install Miniconda
        uses: conda-incubator/setup-miniconda@v3
        with:
          python-version: ${{ inputs.python_version }}

      - name: Set up Conda environment
        run: |
          set -Eeuo pipefail
          eval "$(conda shell.bash hook)"
          cd benchmarks/matbench_v0.1_${{ inputs.model }}

          # 如果提供了 conda env yaml，优先用它创建环境
          if [ ! -z "${{ inputs.conda_env_file }}" ] && [ -f "${{ inputs.conda_env_file }}" ]; then
            echo "Setting up Conda environment from YAML file: ${{ inputs.conda_env_file }}"
            conda env create --name ${{ inputs.model }} --file ${{ inputs.conda_env_file }}
            echo "Conda environment created with ${{ inputs.conda_env_file }}. Exiting step..."
            exit 0  
          fi

          # 否则先创建一个基础环境
          conda create -y --name ${{ inputs.model }} python=${{ inputs.python_version }}

          # 激活环境
          conda activate ${{ inputs.model }} 

          # 如果提供了 requirements.txt，用它装依赖
          if [ ! -z "${{ inputs.pip_requirements_file }}" ] && [ -f "${{ inputs.pip_requirements_file }}" ]; then
            echo "Installing pip dependencies from file: ${{ inputs.pip_requirements_file }}"
            pip install -r ${{ inputs.pip_requirements_file }}
            echo "Conda environment created with ${{ inputs.pip_requirements_file }}. Exiting step..."
            exit 0  

          # 如果提供了自定义 pip 命令，执行它
          elif [ ! -z "${{ inputs.custom_pip_lines }}" ]; then
            echo "Installing custom requirements: ${{ inputs.custom_pip_lines }}"
            eval "${{ inputs.custom_pip_lines }}"
            echo "Conda environment created with custom requirements. Exiting step..."
            exit 0

          else
            # 否则从 info.json 自动解析 python requirements
            PACKAGES=$(python -c "import json;d=json.load(open('info.json'));f=lambda x:[x] if isinstance(x,str) else [y for i in x for y in f(i)] if isinstance(x,(list,tuple)) else [y for v in x.values() for y in f(v)] if isinstance(x,dict) else [];seen=set();out=[];[out.append(s) or seen.add(s) for s in (t.strip() for t in f(d.get('requirements',{}).get('python',[]))) if s and s not in seen];print(' '.join(out))")

            echo "PACKAGES: $PACKAGES"              
              
            PACKAGES_CONDA=${PACKAGES//==/=}
            pip install $PACKAGES || conda install $PACKAGES_CONDA -c conda-forge -c pytorch -c pyg -y
            echo "Conda environment created with info.json. Exiting step..."
          fi

      - name: Install matbench
        run: |
          set -Eeuo pipefail
          eval "$(conda shell.bash hook)"
          cd benchmarks/matbench_v0.1_${{ inputs.model }}

          conda activate ${{ inputs.model }}
          if python -c "import importlib.util,sys; sys.exit(0 if importlib.util.find_spec('matbench') else 1)"; then
            echo "matbench already installed, skipping."
            exit 0
          else
            pip install matbench
          fi

      - name: Run the importing test and export env
        shell: bash -l {0}
        run: |
          set -Eeuo pipefail
      
          eval "$(conda shell.bash hook)"
          cd "benchmarks/matbench_v0.1_${{ inputs.model }}"
      
          conda activate "${{ inputs.model }}"
      
          # 确保 nbconvert / jupyter-core 可用
          if ! python -c "import nbconvert, jupyter_core" >/dev/null 2>&1; then
            conda install -y nbconvert jupyter-core || python -m pip install -U nbconvert jupyter
          fi
      
          shopt -s nullglob
      
          # 将所有 notebook 转成 script
          for nb in *.ipynb; do
            python -m jupyter nbconvert --to script "$nb"
          done
      
          # 收集所有 .py 文件中的 import，生成 imports_only.py
          python -c "import ast,pathlib; m=set(); [m.add(a.name.split('.')[0]) for p in pathlib.Path('.').glob('*.py') if p.name!='imports_only.py' for node in ast.walk(ast.parse(p.read_text(encoding='utf-8',errors='ignore'),filename=str(p))) if isinstance(node,ast.Import) for a in node.names]; [m.add(node.module.split('.')[0]) for p in pathlib.Path('.').glob('*.py') if p.name!='imports_only.py' for node in ast.walk(ast.parse(p.read_text(encoding='utf-8',errors='ignore'),filename=str(p))) if isinstance(node,ast.ImportFrom) and node.level==0 and node.module]; open('imports_only.py','w',encoding='utf-8').write(''.join(f'import {x}\n' for x in sorted(filter(None,m))))"
      
          # 运行导入测试
          python imports_only.py
          
          # 导出 Conda 环境
          OUT="${{ inputs.model }}-${{ inputs.python_version }}.yml"
          conda env export -n "${{ inputs.model }}" --no-builds | sed '/^prefix: /d' > "$OUT"
          echo "Environment exported to: $OUT"
          ls -lh "$OUT"

      - name: Upload exported env
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.model }}-${{ inputs.python_version }}-env
          path: benchmarks/matbench_v0.1_${{ inputs.model }}/${{ inputs.model }}-${{ inputs.python_version }}.yml
          if-no-files-found: error

      # === 从这里开始是 Docker 相关的新增步骤 ===

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Generate Dockerfile
        run: |
          set -Eeuo pipefail
          cd benchmarks/matbench_v0.1_${{ inputs.model }}

          # 拷贝导出的 env 文件为 env.yml（Docker 里使用这个名字）
          cp "${{ inputs.model }}-${{ inputs.python_version }}.yml" env.yml

          echo "Generating Dockerfile..."
          cat > Dockerfile << 'EOF'
          FROM continuumio/miniconda3

          # 将环境文件拷贝进镜像
          WORKDIR /workspace
          COPY env.yml /tmp/env.yml

          # 基于 env.yml 创建 Conda 环境
          RUN conda env create -f /tmp/env.yml && conda clean -afy

          # 将环境加入 PATH，这里假设 env 名就是模型名；如果 env.yml 里写了别的 name，可以改成相应名字
          ENV PATH=/opt/conda/envs/${MODEL_NAME}/bin:$PATH

          # 拷贝代码
          COPY . /workspace

          # 默认启动 bash，你可以按需要改成运行某个脚本
          CMD ["bash"]
          EOF

          # 用 sed 把占位符 MODEL_NAME 替换成真实的 model 名
          sed -i "s/\${MODEL_NAME}/${{ inputs.model }}/g" Dockerfile

          echo "Dockerfile generated:"
          cat Dockerfile

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: benchmarks/matbench_v0.1_${{ inputs.model }}
          push: true
          tags: ${{ inputs.dockerhub_repo }}:${{ inputs.model }}-py${{ inputs.python_version }}
